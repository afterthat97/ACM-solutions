---
title: hihoCoder 编程练习赛45 题解
date: 2018-01-26 12:13:09
categories:
  - hihocoder
---

比赛地址：http://hihocoder.com/contest/offers45

这四道题难度有点偏低啊，榜上一堆满分的大佬...

<!-- more -->

## 互补二元组

给定 $N$ 个整数二元组 $(X_1, Y_1), (X_2, Y_2), ... (X_N, Y_N)$。  

计算其中有多少对二元组 $(X_i, Y_i)$ 和 $(X_j, Y_j)$ 满足 $X_i + X_j = Y_i + Y_j$ 且 $i ＜ j$。

$1 ≤ N ≤ 100000, -1000000 ≤ X_i, Y_i ≤ 1000000$

### 思路

将等式移项：

$$ (X_i - Y_i) + (X_j - Y_j) = 0 $$

于是题目就转化为：令 $Z_i = X_i - Y_i$，求 $Z$ 数组中满足 $Z_i + Z_j = 0$ 的项的数目，这就是一个 two-sum 问题，LeetCode 001。

{% include_code acm-solutions/hihocoder/offer45/1.cpp %}

## 寻找切线

给定二维平面上 $N$ 个点 $P_1=(X_1, Y_1), P_2=(X_2, Y_2), ... P_N=(X_N, Y_N)$。从中找到两个不同的点 $P_i$ 和 $P_j$ 满足：其他所有点都在 $P_i$ 和 $P_j$ 连线的同一侧（可以在连线上）。

### 思路

选所有点中 $X$ 坐标最小（或最大）的点作为 $P_i$，遍历剩下的所有点，找出一个与 $P_i$ 连线斜率最小（或最大）的点作为 $P_j$ 即可。时间复杂度 $O(N)$。

{% include_code acm-solutions/hihocoder/offer45/2.cpp %}

## LR问题

给定两个字符串 $S$ 和 $T$，每个字符串都由 `L`、`R`和 `_` 组成（例如 `R__LR_R_L`）

每一次操作，可以将 $S$ 中的一个 `R` 与它右边相邻的 `_` 交换(前提是这个 `R` 右边相邻位置就是 `_`)；或者将 $S$ 中的一个 `L` 与它左边相邻的 `_` 交换(前提是这个 `L` 左边相邻位置就是 `_`)。

例如，先移动第一个 `L`，再移动第二个 `R` 会得到：

`R__LR_R_L` --> `R_L_R_R_L` --> `R_L__RR_L`

计算最少经过几次操作可以将 $S$ 变成 $T$。

### 思路

由于每次交换都是将某个字母和一个下划线交换，因此无论如何交换，字符串中 `L` 和 `R` 的顺序永远不会变（也就是说，如果忽略下划线字符，那么交换前后的字符串完全相同）。

首先，可以忽略 $S$ 和 $T$ 中的下划线，将两个字符串比较。如果不一致，那么 $S$ 永远不可能变成 $T$。

如果比较的结果一致，那么这也就确定了两个字符串中字母的对应关系。

比如对于 $S$ 中某个 `L` 的下标为 `idx1`（此时不再忽略下划线），它在 $T$ 中对应的 `L` 的下标为 `idx2`，如果 `idx1 >= idx2`，那么就可以将这个 `L` 左移 `idx1 - idx2` 次；否则，由于 `L` 只能左移，而其目的下标在右侧，这就不可能实现，$S$ 永远不可能变成 $T$。`R` 同理。

时间复杂度 $O(N)$。

{% include_code acm-solutions/hihocoder/offer45/3.cpp %}

## 推断大小关系

有 $N$ 个整数 $A_1, A_2, ... A_N$，现在我们知道 $M$ 条关于这 $N$ 个整数的信息。每条信息可能是 $A_i < A_j$ 或 $A_i = A_j$。

从第一条信息开始依次逐条处理这些信息，一旦能推断出 $A_1$ 和 $A_N$ 的大小关系就立即停止。

输出在处理第几条时首次推断出 $A_1$ 和 $A_N$ 的关系。如果处理完全部M条信息还是不知道 $A_1$ 和 $A_N$ 的大小关系，输出 `-1`。  

保证 $M$ 条信息是没有矛盾的。

$1 ≤ N ≤ 100000, 1 ≤ N ≤ 1000000$

### 思路1（代码思路）

将 $A_1, A_2, ... A_N$ 看作有向图中的 $N$ 个结点。

对于每一条消息，如果 $A_i < A_j$，那就从 $A_i$ 到 $A_j$ 连一条单向边；如果 $A_i = A_j$，那就从 $A_i$ 到 $A_j$ 连双向边。边的权值就是消息的编号。一条路径的权值定义为其经过的所有边的最大权值。

于是问题转化为，是否存在从 $A_1$ 到 $A_N$ ，或从 $A_N$ 到 $A_1$ 的一条路径。如果存在多条，输出权值最小的路径。分别从 $A_1$ 和 $A_N$ 开始 DFS 即可解决。

### 思路2（正解）

依然将 $A_1, A_2, ... A_N$ 看作有向图中的 $N$ 个结点。

依然对于每一条消息，如果 $A_i < A_j$，那就从 $A_i$ 到 $A_j$ 连一条单向边；如果 $A_i = A_j$，那就从 $A_i$ 到 $A_j$ 连双向边。

仅讨论从 $A_1$ 到 $A_N$：把节点染成 2 种颜色：对于 $A_1$ 能到达的点染红色，不能到达的点染白色。初始时只有 $A_1$ 是红色，其余都是白色。当 $A_N$ 第一次染红时，就是 $A_1$ 到 $A_N$ 首次联通之时。
假设加入一条边 `a->b` 时：* 如果 `b`是红色的，直接忽略* 如果 `a, b` 都是白色的，把这条边加入边集* 如果 `a` 是红色，`b` 是白色，从 `b` 开始 DFS(只扩展白色结点，并且其染红)

时间复杂度 $O(M)$。

{% include_code acm-solutions/hihocoder/offer45/4.cpp %}