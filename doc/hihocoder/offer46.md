---
title: hihoCoder 编程练习赛46 题解
date: 2018-01-28 20:47:08
categories:
  - hihocoder
mathjax: true
---

比赛地址：http://hihocoder.com/contest/offers46

一共四题，难度不是很高。最后两题被 `long long` 卡了很久，尤其最后一题，比赛结束后4分钟满分通过了...就是因为 `long long`。

<!-- more -->

## AEIOU

给定一个只包含 a, e, i, o, u 的字符串 $S$，请你找到其中的最长的子序列，满足：

1. 所有的 `a` 都在 `e` 和 `i` 之前，所有的 `e` 都在 `i` 之前

2. 所有的 `o` 都在 `u` 之前

输出最长满足条件的子序列的长度。  

例如对于 $S$ = `aeiouaeiou`，满足条件的最长的子序列有 `aoaeiou`, `aeiouiu`等。长度都是 7。

### 思路

首先可以注意到，`a, e, i` 和 `o, u` 互不相关，可以分开考虑。

比如对于一个仅有 `a, e, i` 三个字符的字符串，满足条件的子序列即为最长不下降子序列。求解最长不下降子序列的时间复杂度是 $O(nlogn)$，但现在只有三个字符，因此完全可以 $O(n)$ 解决。

将字符串从前向后遍历，用 `int` 变量 `A`, `E`, `I` 分别记录当前以 `a`, `e`, `i` 结尾的符合要求的子序列最长长度。`O`, `U` 同理。最后输出这五个变量的最大值即可。

{% include_code acm-solutions/hihocoder/offer46/1.cpp %}

## 数字游戏

给出两个 $N （1 ≤ N ≤ 10）$ 位整数 $A$ 和 $B$ (可能有前导 0)，需要经过最少次数的变换将 $A$ 变成 $B$？

一次变换可以进行以下操作之一：

1. 交换任意两位数字。例如 `12345` -> `42315`。  

2. 选择任意一位数字加 1 或减 1。注意 0 减 1 会变成 9 ，9 加 1 会变成 0。

### 思路

第一想法肯定是 BFS 搜索，但是复杂度相当高，具体没算。

进一步研究可以发现，这两种操作之间并没有关系。也就是说，颠倒任意两次操作，结果不变。因此，可以先考虑交换操作。将一个长度为 $N$ 的序列经过若干次的交换操作后，可能会有 $N!$ 种情况（正是全排列）。因此，可以枚举数字串 $A$ 的 $N!$ 个全排列，每个排列恰好对应于一个交换方案。交换方案确定了，只要按位进行加减操作就行了。时间复杂度 $O(N * N!)$

{% include_code acm-solutions/hihocoder/offer46/2.cpp %}

## 第K小分数

给定 $N$ 个不同的质数 $P_1, P_2, ... P_N$。用它们作为分母可以组成 $(P_1-1) + (P_2-1) + ... (P_N-1)$ 个分数：

$$1/P_1, 2/P_1, 3/P_1, ... (P_1-1)/P_1, $$
$$1/P_2, 2/P_2, 3/P_2, ... (P_2-1)/P_2, $$
$$...$$
$$1/P_N, 2/P_N, 3/P_N, ... (P_N-1)/P_N$$

求出其中第 $K$ 小的分数。

$1 ≤ N ≤ 10^3, 1 ≤ K ≤ 10^9, 2 ≤ P_i ≤ 10^9$

### 思路

不难想到类似 $N$ 路归并的解法：
--> $1/P_1, 2/P_1, 3/P_1...$--> $1/P_2, 2/P_2, 3/P_2...$--> $1/P_3, 2/P_3, 3/P_3...$但时间复杂度 $O(KlogN)$ 适合 $N$ 较大，$K$ 较小的情况，与题目恰好相反。

正解是二分搜索，只不过这不像往常一样对整数进行二分，而是在 $[0, 1]$ 中对浮点数进行二分。对于某个浮点数阈值，如果整个数列中中恰好有 $K$ 个比他小，那么最接近这个阈值、且比他小的分数就是答案。

对于浮点数阈值 $v$，则整个数列中比他小的数的个数为：

$$\sum_{i=0}^{n-1}\lfloor P_i * v \rfloor$$

{% include_code acm-solutions/hihocoder/offer46/3.cpp %}

## 逆序异或和

给定长度为 $N$ 的序列 $A_1, A_2, ... A_N$，求：

$$\sum_{i＜j,A_i＞A_j}Ai \oplus Aj$$

其中 $1 ≤ N ≤ 10^5, 1 ≤ A_i ≤ 10^5$。

### 思路

对于 $A_i$ 的二进制每一位，都要维护两个集合 $S_0 = \{A_i | A_i.bit[k]=0\}$，$S_1=\{A_i | A_i.bit[k]=1\}$。其中 $k$ 指二进制第 $k$ 位。
* 若 $A_j.bit[k]=0$，则要求 $S_1$ 中大于 $A_j$ 的元素有几个* 若 $A_j.bit[k]=1$，则要求 $S_0$ 中大于 $A_j$ 的元素有几个

求出满足的元素个数后，每个元素对最终结果的贡献是 $2^k$。

这就和求解逆序对的树状数组思想一样，这不过这里要把 $A_i$ 转化为二进制，对每一位开两个树状数组，分别对应 $S_0$ 和 $S_1$。

{% include_code acm-solutions/hihocoder/offer46/4.cpp %}
